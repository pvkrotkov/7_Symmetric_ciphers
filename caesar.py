import pandas as pd
N = 2**16-1
test_text = """Шифр Цезаря 
Классический шифр Цезаря предполагает смещение каждой буквы текста на следующую за ней через три. Последние буквы 
смещаются в начало алфавита по кольцу. Мы будем использовать модифицированный алгоритм, в котором ключом является целое 
число - величина смещения. Работать с алфавитом программно не очень удобно, да и нет никакой необходимости. Мы 
воспользуемся кодировкой текста - соответствием между символами и целыми числами. В питоне встроены очень полезные 
функции: ord(c) - возвращает число, соответствующее символу с в кодировке unicode; chr(i) - наоборот, возвращает символ 
по его целочисленному коду. Для реализации шифра Цезаря нам нужно написать две функции - encrypt(k, m) и decrypt(k, c). 
Первая принимает в качестве аргументов число, служащее ключом и строку текста. Она должна превратить строку в массив 
чисел используя функцию ord(), затем прибавить к каждому числу ключ и преобразовать получившийся массив чисел в строку. 
Обратите внимание, что чтобы исключить выход за границы кодировки операцию сложения необходимо производить по модулю 
65536 - это максимальное число, поддерживающееся функцией chr(). 
Функция дешифрования работает аналогично, но вместо сложения, вычитает ключ из каждого символа"""


def encrypt_caesar(k, m):
    """
    :param k: ключ
    :param m: шифруемая строка
    :return: зашифрованный текст
    """
    return ''.join(map(chr, [(x + k) % N for x in map(ord, m)]))


def decrypt_caesar(k, c):
    """
    :param k: ключ
    :param c: текст для расшифровки
    :return: расшифрованный текст
    """
    return ''.join(map(chr, [(x - k) % N for x in map(ord, c)]))


def break_caesar(p):
    """
    :param p: зашифрованный текст
    :return: расшифрованный текст
    Функция работает из соображений частотного анализа текста, где самый частый элемент - пробел,
    рекомендуется передавать текст от 15 слов.
    """
    df = pd.DataFrame({'letter': list(p), 'amount': 0})
    key = ord(str(df.groupby('letter').count().sort_values(by='amount', ascending=False).head(1)).split()[2]) - ord(' ')
    return decrypt_caesar(key, p)


key = int(input('Введите ключ (смещение): '))
x = encrypt_caesar(key, test_text)
print(f"Encrypted: {x}\n\n\n")
print(f"Decrypted: {decrypt_caesar(key, x)}\n\n\n")
print(f"Broken: {break_caesar(x)}")
