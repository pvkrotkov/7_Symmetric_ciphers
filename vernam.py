import math
test_text = """Шифр Цезаря 
Классический шифр Цезаря предполагает смещение каждой буквы текста на следующую за ней через три. Последние буквы 
смещаются в начало алфавита по кольцу. Мы будем использовать модифицированный алгоритм, в котором ключом является целое 
число - величина смещения. Работать с алфавитом программно не очень удобно, да и нет никакой необходимости. Мы 
воспользуемся кодировкой текста - соответствием между символами и целыми числами. В питоне встроены очень полезные 
функции: ord(c) - возвращает число, соответствующее символу с в кодировке unicode; chr(i) - наоборот, возвращает символ 
по его целочисленному коду. Для реализации шифра Цезаря нам нужно написать две функции - encrypt(k, m) и decrypt(k, c). 
Первая принимает в качестве аргументов число, служащее ключом и строку текста. Она должна превратить строку в массив 
чисел используя функцию ord(), затем прибавить к каждому числу ключ и преобразовать получившийся массив чисел в строку. 
Обратите внимание, что чтобы исключить выход за границы кодировки операцию сложения необходимо производить по модулю 
65536 - это максимальное число, поддерживающееся функцией chr(). 
Функция дешифрования работает аналогично, но вместо сложения, вычитает ключ из каждого символа"""


def use_vernam(k, m):
    """
    :param k: ключ
    :param m: контекст
    :return: шифр конекст по Вернаму с указанным ключом
    В силу обратимости операции XOR функция работает и как encrypt, и как decrypt
    """
    k = (k * math.ceil(len(m) / len(k)))[:len(m)]
    return ''.join(map(chr, [letter ^ ord(k[i]) for i, letter in enumerate([x for x in map(ord,m)])]))


key = 'qwertylkjhgf'
# защифруем строку
enc = use_vernam(key, test_text)
# расшифруем строку
dec = use_vernam(key, enc)
print(dec)